module reconstruction
  use m_common
  use funit

  real*8, parameter         :: TOLERANCE = 1E-10
  real*8, parameter         :: IS_INTERFACE_TOLERANCE = 1E-8
contains
  @Test
  subroutine test_exact_mof_reconstruction()
    use m_reconstruction_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, max_shift_plane, dx(2), pi
    real*8                :: refMoments(3), mofMoments(3), recNormal(2)
    integer               :: adx, sdx

    integer, parameter    :: NR_ANGLE = 30, NR_SHIFT = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, pi/10]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      refMoments = cmpMoments(normal, dx, shift)
      
      recNormal = mofNormal(refMoments, dx, mofMoments)

      @assertEqual(normal, recNormal, TOLERANCE)
      @assertEqual(refMoments, mofMoments, TOLERANCE)
      
      recNormal = pmofNormal(refMoments, 0.0D0, dx, errTol=TOLERANCE, verbose=.false.)

      @assertEqual(normal, recNormal, TOLERANCE)
    enddo
    enddo
  end subroutine

  @Test
  subroutine test_exact_pmof_reconstruction()
    use m_reconstruction_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, kappa0, max_shift_plane, dx(2)
    real*8                :: refMoments(3), recNormal(2), pi
    integer               :: adx, sdx, kdx

    integer, parameter    :: NR_ANGLE = 30, NR_SHIFT = 30, NR_KAPPA = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]

      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      refMoments = cmpMoments(dx, makeParabola(normal, shift, kappa0))
      
      if (refMoments(1) > IS_INTERFACE_TOLERANCE .and. product(dx) - refMoments(1) > IS_INTERFACE_TOLERANCE) then
        recNormal = pmofNormal(refMoments, kappa0, dx, errTol=TOLERANCE/10, verbose=.false.)

        @assertEqual(normal, recNormal, TOLERANCE)
      endif
    enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_exact_plvira_reconstruction()
    use m_reconstruction_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, kappa0, max_shift_plane, dxs(-1:1,2)
    real*8                :: refVolumes(-1:1,-1:1), recNormal(2), pi, refMoments(3)
    real*8                :: xc_neighbour(2), dx_neighbour(2)
    integer               :: adx, sdx, kdx, i, j

    integer, parameter    :: NR_ANGLE = 30, NR_SHIFT = 30, NR_KAPPA = 30

    pi = 4 * datan(1.0D0)

    ! dxs(:,1) is dx and dxs(:,2) is dy for the 3x3 rectilinear grid
    dxs(-1:1,1) = [1., 0.9, 0.5]
    dxs(-1:1,2) = [pi/5, pi/4, pi/3]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]

      max_shift_plane = dot_product(abs(normal), dxs(0,:)) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      do j=-1,1
      do i=-1,1
        dx_neighbour(1) = dxs(i, 1)
        dx_neighbour(2) = dxs(j, 2)

        xc_neighbour(1) = i * (dxs(0,1) + dx_neighbour(1))/2
        xc_neighbour(2) = j * (dxs(0,2) + dx_neighbour(2))/2

        ! NOTE: x0 refers to the position relative to which the interface is defined
        refMoments = cmpMoments(dx_neighbour, makeParabola(normal, kappa0,  shift), x0=-xc_neighbour)
        refVolumes(i,j) = refMoments(1)
      enddo
      enddo
      
      if (refVolumes(0,0) > IS_INTERFACE_TOLERANCE .and. product(dxs(0,:)) - refVolumes(0,0) > IS_INTERFACE_TOLERANCE) then
        recNormal = plviraNormal(refVolumes, kappa0, dxs, errTol=TOLERANCE/10, verbose=.true.)

        print*, '     angle = ', angle
        print*, '     shift = ', shift
        print*, '    kappa0 = ', kappa0
        do j=1,-1,-1
          print*, '             ', [refVolumes(-1,j)/dxs(-1,1), refVolumes(0,j)/dxs(0,1), refVolumes(1,j)/dxs(1,1)]/dxs(j,2)
        enddo

        @assertEqual(normal, recNormal, TOLERANCE)
        return
      endif
    enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_shift_volume_consistency()
    use m_reconstruction_util
    use m_r2d_parabolic

    implicit none
    
    real*8                :: angle, normal(2), kappa0, shift, shift_recomputed, dx(2)
    real*8                :: moments01(3), moments01_recomputed(3), pi, max_shift_plane
    integer               :: adx, kdx, sdx

    integer, parameter    :: NR_ANGLE = 30, NR_KAPPA = 30, NR_SHIFT = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * (sdx - 1.D0) / (NR_SHIFT - 1.D0))

      moments01 = cmpMoments(normal, dx, shift)
      shift_recomputed = cmpShift(normal, dx, moments01(1))

      if (shift <= -max_shift_plane) then
        @assertLessThanOrEqual(shift_recomputed, -max_shift_plane)
        @assertEqual(0.D0, moments01(1), TOLERANCE)
      elseif (shift >= max_shift_plane) then
        @assertGreaterThanOrEqual(shift_recomputed, max_shift_plane)
        @assertEqual(product(dx), moments01(1), TOLERANCE)
      else
        @assertEqual(shift, shift_recomputed, TOLERANCE)
      endif

      moments01_recomputed = cmpMoments(normal, dx, shift_recomputed)
      @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      
      do kdx=1,NR_KAPPA
        kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

        moments01 = cmpMoments(dx, makeParabola(normal, kappa0, shift))
        shift_recomputed = cmpShift(normal, dx, moments01(1), kappa0, moments=moments01_recomputed)
        @assertEqual(moments01, moments01_recomputed, TOLERANCE)

        if (moments01(1) < TOLERANCE) then
          
        elseif (product(dx) - moments01(1) < TOLERANCE) then
          
        else
          @assertEqual(shift, shift_recomputed, TOLERANCE)
        endif

        moments01_recomputed = cmpMoments(dx, makeParabola(normal, kappa0, shift_recomputed))
        @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      enddo
    enddo
    enddo

  end subroutine


  @Test
  subroutine test_approx_reconstruction()

  contains
    real*8 function levelSet(x) result(ans)
      implicit none

      real*8, intent(in)  :: x(2)

      ! ans = shift - dot_product(x, normal) - (kappa0/2) * (dot_product(x, tangent))**2

    end function
  end subroutine
end module