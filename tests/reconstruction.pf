module reconstruction
  use m_common
  use funit

  real*8, parameter         :: TOLERANCE = 1E-12
contains
  @Test
  subroutine test_exact_plic_reconstruction()
    use m_plic_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, max_shift_plane, dx(2), pi
    real*8                :: refMoments(3), mofMoments(3), mofNormal(2), mofAngle
    integer               :: adx, sdx

    integer, parameter    :: NR_ANGLE = 30, NR_SHIFT = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, pi/10]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      refMoments = reference_moments(LIQUID_PHASE, [0.D0, 0.D0], dx, levelSet, verts_per_segment=2)
      
      print*, ''
      mofNormal = plic_normal_mof2d(refMoments, dx, mofMoments)
      mofAngle = datan2(mofNormal(2), mofNormal(1))

      print*, 'centroid = ', refMoments(2:3) / (.5*dx * refMoments(1))
      print*, '   shift = ', shift
      print*, '   angle = ', angle
      print*, 'mofAngle = ', mofAngle
      @assertEqual(angle, mofAngle, TOLERANCE)
      @assertEqual(refMoments, mofMoments, TOLERANCE)
    enddo
    enddo
  contains
    ! The liquid part coincides with levelSet(x) < 0 (normal points into gas)
    real*8 function levelSet(x) result(ans)
      implicit none

      real*8, intent(in)  :: x(2)

      ans = dot_product(x, normal) - shift

    end function
  end subroutine

  @Test
  subroutine test_exact_ppic_reconstruction()
    use m_ppic_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), tangent(2), shift, kappa0, max_shift_plane, dx(2)
    real*8                :: refMoments(3), mofMoments(3), mofNormal(2), mofAngle, pi
    integer               :: adx, sdx, kdx

    integer, parameter    :: NR_ANGLE = 30, NR_SHIFT = 30, NR_KAPPA = 30
return
    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]
      tangent = [-normal(2), normal(1)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      refMoments = reference_moments(LIQUID_PHASE, [0.D0, 0.D0], dx, levelSet)
      
      if (refMoments(1) > TOLERANCE .and. product(dx) - refMoments(1) > TOLERANCE) then
        mofNormal = ppic_normal_pmof2d(refMoments, kappa0, dx, mofMoments, errTol=TOLERANCE/10)
        mofAngle = datan2(mofNormal(2), mofNormal(1))

        ! print*, angle, mofAngle
        @assertEqual(angle, mofAngle, TOLERANCE)
        @assertEqual(refMoments, mofMoments, TOLERANCE)
      endif
    enddo
    enddo
    enddo
  contains
    real*8 function levelSet(x) result(ans)
      implicit none

      real*8, intent(in)  :: x(2)

      ans = shift - dot_product(x, normal) - (kappa0/2) * (dot_product(x, tangent))**2

    end function
  end subroutine

  @Test
  subroutine test_shift_volume_consistency()
    use m_plic_util
    use m_ppic_util

    implicit none
    
    real*8                :: angle, normal(2), kappa0, shift, shift_recomputed, dx(2)
    real*8                :: moments01(3), moments01_recomputed(3), pi, max_shift_plane
    integer               :: adx, kdx, sdx

    integer, parameter    :: NR_ANGLE = 30, NR_KAPPA = 30, NR_SHIFT = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * (sdx - 1.D0) / (NR_SHIFT - 1.D0))

      moments01 = cmpMoments2d(normal, dx, shift)
      shift_recomputed = cmpShift2d(normal, dx, moments01(1))

      if (shift <= -max_shift_plane) then
        @assertLessThanOrEqual(shift_recomputed, -max_shift_plane)
        @assertEqual(0.D0, moments01(1), TOLERANCE)
      elseif (shift >= max_shift_plane) then
        @assertGreaterThanOrEqual(shift_recomputed, max_shift_plane)
        @assertEqual(product(dx), moments01(1), TOLERANCE)
      else
        @assertEqual(shift, shift_recomputed, TOLERANCE)
      endif

      moments01_recomputed = cmpMoments2d(normal, dx, shift_recomputed)
      @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      
      do kdx=1,NR_KAPPA
        kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

        moments01 = cmpMoments2d_parabolic(normal, dx, shift, kappa0)
        shift_recomputed = cmpShift2d_parabolic(normal, dx, moments01(1), kappa0)

        if (moments01(1) < TOLERANCE) then
          
        elseif (product(dx) - moments01(1) < TOLERANCE) then
          
        else
          @assertEqual(shift, shift_recomputed, TOLERANCE)
        endif

        moments01_recomputed = cmpMoments2d_parabolic(normal, dx, shift_recomputed, kappa0)
        @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      enddo
    enddo
    enddo

  end subroutine

end module