module reconstruction
  use m_common
  use funit

  real*8, parameter         :: TOLERANCE = 1E-10
  real*8, parameter         :: IS_INTERFACE_TOLERANCE = 1E-8
contains
  @Test
  subroutine test_exact_mof_reconstruction()
    use m_reconstruction_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, max_shift_plane, dx(2), pi
    real*8                :: refMoments(3), mofMoments(3), recNormal(2)
    integer               :: adx, sdx

    integer, parameter    :: NR_ANGLE = 20, NR_SHIFT = 20

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, pi/10]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      refMoments = cmpMoments(normal, dx, shift)
      
      recNormal = mofNormal(refMoments, dx, mofMoments)

      @assertEqual(normal, recNormal, TOLERANCE)
      @assertEqual(refMoments, mofMoments, TOLERANCE)
      
      recNormal = pmofNormal(refMoments, 0.0D0, dx, errTol=TOLERANCE, verbose=.false.)

      @assertEqual(normal, recNormal, TOLERANCE)
    enddo
    enddo
  end subroutine

  @Test
  subroutine test_exact_pmof_reconstruction()
    use m_reconstruction_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, kappa0, max_shift_plane, dx(2)
    real*8                :: refMoments(3), recMoments(3), recNormal(2), pi, recShift
    integer               :: adx, sdx, kdx

    integer, parameter    :: NR_ANGLE = 20, NR_SHIFT = 20, NR_KAPPA = 20

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]

      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      refMoments = cmpMoments(dx, makeParabola(normal, kappa0, shift))
      
      if (refMoments(1) > IS_INTERFACE_TOLERANCE .and. product(dx) - refMoments(1) > IS_INTERFACE_TOLERANCE) then
        recNormal = pmofNormal(refMoments, kappa0, dx, errTol=TOLERANCE, verbose=.false.)
        @assertEqual(normal, recNormal, TOLERANCE)

        recShift = cmpShift(recNormal, dx, refMoments(1), kappa0, moments=recMoments)
        @assertEqual(refMoments, recMoments, TOLERANCE * product(dx))
      endif
    enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_exact_plvira_reconstruction()
    use m_reconstruction_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, kappa0, max_shift_plane, dxs(-1:1,2)
    real*8                :: refVolumes(-1:1,-1:1), recNormal(2), pi, refMoments(3), recShift
    real*8                :: xc_neighbour(2), dx_neighbour(2)
    integer               :: adx, sdx, kdx, i, j

    integer, parameter    :: NR_ANGLE = 20, NR_SHIFT = 20, NR_KAPPA = 20

    pi = 4 * datan(1.0D0)

    ! dxs(:,1) is dx and dxs(:,2) is dy for the 3x3 rectilinear grid
    dxs(-1:1,1) = [1., 0.9, 0.5]
    dxs(-1:1,2) = [pi/5, pi/4, pi/3]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]

      max_shift_plane = dot_product(abs(normal), dxs(0,:)) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      do j=-1,1
      do i=-1,1
        dx_neighbour(1) = dxs(i, 1)
        dx_neighbour(2) = dxs(j, 2)

        xc_neighbour(1) = i * (dxs(0,1) + dx_neighbour(1))/2
        xc_neighbour(2) = j * (dxs(0,2) + dx_neighbour(2))/2

        ! NOTE: x0 refers to the position relative to which the interface is defined
        refMoments = cmpMoments(dx_neighbour, makeParabola(normal, kappa0,  shift), x0=-xc_neighbour)
        refVolumes(i,j) = refMoments(1)
      enddo
      enddo
      
      if (refVolumes(0,0) > IS_INTERFACE_TOLERANCE .and. product(dxs(0,:)) - refVolumes(0,0) > IS_INTERFACE_TOLERANCE) then
        recNormal = plviraNormal(refVolumes, kappa0, dxs, errTol=TOLERANCE, verbose=.false.)
        @assertEqual(normal, recNormal, TOLERANCE)
        
        recShift = cmpShift(recNormal, dxs(0,:), refVolumes(0,0), kappa0)
        @assertEqual(shift, recShift, TOLERANCE)
      endif
    enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_exact_prost_reconstruction()
    use m_reconstruction_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, kappa0, max_shift_plane, dxs(-1:1,2)
    real*8                :: refVolumes(-1:1,-1:1), recNormal(2), pi, refMoments(3), recShift, recKappa0
    real*8                :: xc_neighbour(2), dx_neighbour(2)
    integer               :: adx, sdx, kdx, i, j

    integer, parameter    :: NR_ANGLE = 20, NR_SHIFT = 20, NR_KAPPA = 20

    pi = 4 * datan(1.0D0)

    ! dxs(:,1) is dx and dxs(:,2) is dy for the 3x3 rectilinear grid
    dxs(-1:1,1) = [1., 0.9, 0.5]
    dxs(-1:1,2) = [pi/5, pi/4, pi/3]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]

      max_shift_plane = dot_product(abs(normal), dxs(0,:)) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      do j=-1,1
      do i=-1,1
        dx_neighbour(1) = dxs(i, 1)
        dx_neighbour(2) = dxs(j, 2)

        xc_neighbour(1) = i * (dxs(0,1) + dx_neighbour(1))/2
        xc_neighbour(2) = j * (dxs(0,2) + dx_neighbour(2))/2

        ! NOTE: x0 refers to the position relative to which the interface is defined
        refMoments = cmpMoments(dx_neighbour, makeParabola(normal, kappa0,  shift), x0=-xc_neighbour)
        refVolumes(i,j) = refMoments(1)
      enddo
      enddo
      
      if (refVolumes(0,0) > IS_INTERFACE_TOLERANCE .and. product(dxs(0,:)) - refVolumes(0,0) > IS_INTERFACE_TOLERANCE) then
        ! Make sure the initial guess is bad
        recKappa0 = kappa0 + 1.
        recNormal = prostNormal(refVolumes, recKappa0, dxs, errTol=TOLERANCE, verbose=.true.)

        print*, '      frac = ', refMoments(1) / product(dxs(0,:))
        print*, ' kappa/rec = ', kappa0, recKappa0
        print*, ' angle/rec = ', angle, datan2(recNormal(2), recNormal(1))

        @assertEqual(normal, recNormal, TOLERANCE)
        @assertEqual(kappa0, recKappa0, TOLERANCE)
        
        recShift = cmpShift(recNormal, dxs(0,:), refVolumes(0,0), kappa0)
        @assertEqual(shift, recShift, TOLERANCE)

      endif
    enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_shift_volume_consistency()
    use m_reconstruction_util
    use m_r2d_parabolic

    implicit none
    
    real*8                :: angle, normal(2), kappa0, shift, shift_recomputed, dx(2)
    real*8                :: moments01(3), moments01_recomputed(3), pi, max_shift_plane
    integer               :: adx, kdx, sdx

    integer, parameter    :: NR_ANGLE = 20, NR_KAPPA = 20, NR_SHIFT = 20

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * (sdx - 1.D0) / (NR_SHIFT - 1.D0))

      moments01 = cmpMoments(normal, dx, shift)
      shift_recomputed = cmpShift(normal, dx, moments01(1))

      if (shift <= -max_shift_plane) then
        @assertLessThanOrEqual(shift_recomputed, -max_shift_plane)
        @assertEqual(0.D0, moments01(1), TOLERANCE)
      elseif (shift >= max_shift_plane) then
        @assertGreaterThanOrEqual(shift_recomputed, max_shift_plane)
        @assertEqual(product(dx), moments01(1), TOLERANCE)
      else
        @assertEqual(shift, shift_recomputed, TOLERANCE)
      endif

      moments01_recomputed = cmpMoments(normal, dx, shift_recomputed)
      @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      
      do kdx=1,NR_KAPPA
        kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

        moments01 = cmpMoments(dx, makeParabola(normal, kappa0, shift))
        shift_recomputed = cmpShift(normal, dx, moments01(1), kappa0, moments=moments01_recomputed)
        @assertEqual(moments01, moments01_recomputed, TOLERANCE)

        if (moments01(1) < TOLERANCE) then
          
        elseif (product(dx) - moments01(1) < TOLERANCE) then
          
        else
          @assertEqual(shift, shift_recomputed, TOLERANCE)
        endif
        
        moments01_recomputed = cmpMoments(dx, makeParabola(normal, kappa0, shift_recomputed))
        @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_shift_volume_consistency_nonrect()
    use m_reconstruction_util
    use m_r2d_parabolic

    implicit none
    
    type(r2d_poly_f)      :: cell
    real*8                :: angle, normal(2), kappa0, shift, shift_recomputed
    real*8                :: x(2), pos(2, 7), radius, cellMoments(3)
    real*8                :: moments01(3), moments01_recomputed(3), pi
    integer               :: adx, kdx, sdx

    integer, parameter    :: NR_ANGLE = 20, NR_KAPPA = 20, NR_SHIFT = 20

    pi = 4 * datan(1.0D0)

    radius = 1.0D0
    x = [0.05D0, 0.03D0]

    ! Reconstruct in a polygonal approximation of a circle
    do adx=1,size(pos,2)
      angle = 2 * pi * (adx - 1.D0) / size(pos,2)
      pos(1,adx) = x(1) + radius * dcos(angle)
      pos(2,adx) = x(2) + radius * dsin(angle)
    enddo
    call init_from_pos(cell, pos)

    cellMoments = cmpMoments(cell)

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]
      
      shift = (radius/2) * (-1.D0 + 2 * (sdx - 1.D0) / (NR_SHIFT - 1.D0))
      
      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      moments01 = cmpMoments(cell, makeParabola(normal, kappa0, shift))
      shift_recomputed = cmpShift(normal, cell, moments01(1), kappa0, moments=moments01_recomputed)
      @assertEqual(moments01, moments01_recomputed, TOLERANCE)

      if (moments01(1) < TOLERANCE) then
        
      elseif (cellMoments(1) - moments01(1) < TOLERANCE) then
        
      else
        @assertEqual(shift, shift_recomputed, TOLERANCE)
      endif

      moments01_recomputed = cmpMoments(cell, makeParabola(normal, kappa0, shift_recomputed))
      @assertEqual(moments01, moments01_recomputed, TOLERANCE)
    enddo
    enddo
    enddo

  end subroutine


  @Test
  subroutine test_approx_reconstruction()

  contains
    real*8 function levelSet(x) result(ans)
      implicit none

      real*8, intent(in)  :: x(2)

      ! ans = shift - dot_product(x, normal) - (kappa0/2) * (dot_product(x, tangent))**2

    end function
  end subroutine
end module