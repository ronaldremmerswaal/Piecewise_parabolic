module reconstruction
  use m_common
  use funit

  real*8, parameter         :: TOLERANCE = 1E-10
  real*8, parameter         :: IS_INTERFACE_TOLERANCE = 1E-8
contains
  @Test
  subroutine test_exact_plic_reconstruction()
    use m_plic_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), shift, max_shift_plane, dx(2), pi
    real*8                :: refMoments(3), mofMoments(3), mofNormal(2)
    integer               :: adx, sdx

    integer, parameter    :: NR_ANGLE = 30, NR_SHIFT = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, pi/10]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      refMoments = cmpMoments2d(normal, dx, shift)
      
      mofNormal = plic_normal_mof2d(refMoments, dx, mofMoments)

      @assertEqual(normal, mofNormal, TOLERANCE)
      @assertEqual(refMoments, mofMoments, TOLERANCE)
      
      mofNormal = ppic_normal_pmof2d(refMoments, 0.0D0, dx, errTol=TOLERANCE, verbose=.false.)
  
      @assertEqual(normal, mofNormal, TOLERANCE)
    enddo
    enddo
  end subroutine

  @Test
  subroutine test_exact_ppic_reconstruction()
    use m_ppic_util
    use m_r2d_parabolic
    use m_reconstruction

    implicit none

    real*8                :: angle, normal(2), tangent(2), shift, kappa0, max_shift_plane, dx(2)
    real*8                :: refMoments(3), mofNormal(2), pi
    integer               :: adx, sdx, kdx

    integer, parameter    :: NR_ANGLE = 30, NR_SHIFT = 30, NR_KAPPA = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
    do kdx=1,NR_KAPPA
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE - pi
      normal = [dcos(angle), dsin(angle)]
      tangent = [-normal(2), normal(1)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      refMoments = cmpMoments2d_parabolic(normal, dx, shift, kappa0)
      
      if (refMoments(1) > IS_INTERFACE_TOLERANCE .and. product(dx) - refMoments(1) > IS_INTERFACE_TOLERANCE) then
        mofNormal = ppic_normal_pmof2d(refMoments, kappa0, dx, errTol=TOLERANCE, verbose=.true.)
  
        print*, ''
        print*, '       angle = ', angle
        print*, '       shift = ', shift
        print*, '      kappa0 = ', kappa0
        print*, '  refMoments = ', refMoments
        print*, '     refFrac = ', refMoments(1) / product(dx)
        print*, ' refCentroid = ', refMoments(2:3) / refMoments(1)
        print*, '      normal = ', normal
        print*, '   morNormal = ', mofNormal

        @assertEqual(normal, mofNormal, TOLERANCE)
      endif
    enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_shift_volume_consistency()
    use m_plic_util
    use m_ppic_util

    implicit none
    
    real*8                :: angle, normal(2), kappa0, shift, shift_recomputed, dx(2)
    real*8                :: moments01(3), moments01_recomputed(3), pi, max_shift_plane
    integer               :: adx, kdx, sdx

    integer, parameter    :: NR_ANGLE = 30, NR_KAPPA = 30, NR_SHIFT = 30

    pi = 4 * datan(1.0D0)

    dx = [0.123D0, 0.3141592D0]

    do adx=1,NR_ANGLE
    do sdx=1,NR_SHIFT
      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]
      
      max_shift_plane = dot_product(abs(normal), dx) / 2
      shift = max_shift_plane * (-1.D0 + 2 * (sdx - 1.D0) / (NR_SHIFT - 1.D0))

      moments01 = cmpMoments2d(normal, dx, shift)
      shift_recomputed = cmpShift2d(normal, dx, moments01(1))

      if (shift <= -max_shift_plane) then
        @assertLessThanOrEqual(shift_recomputed, -max_shift_plane)
        @assertEqual(0.D0, moments01(1), TOLERANCE)
      elseif (shift >= max_shift_plane) then
        @assertGreaterThanOrEqual(shift_recomputed, max_shift_plane)
        @assertEqual(product(dx), moments01(1), TOLERANCE)
      else
        @assertEqual(shift, shift_recomputed, TOLERANCE)
      endif

      moments01_recomputed = cmpMoments2d(normal, dx, shift_recomputed)
      @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      
      do kdx=1,NR_KAPPA
        kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

        moments01 = cmpMoments2d_parabolic(normal, dx, shift, kappa0)
        shift_recomputed = cmpShift2d_parabolic(normal, dx, moments01(1), kappa0, moments=moments01_recomputed)
        @assertEqual(moments01, moments01_recomputed, TOLERANCE)

        if (moments01(1) < TOLERANCE) then
          
        elseif (product(dx) - moments01(1) < TOLERANCE) then
          
        else
          @assertEqual(shift, shift_recomputed, TOLERANCE)
        endif

        moments01_recomputed = cmpMoments2d_parabolic(normal, dx, shift_recomputed, kappa0)
        @assertEqual(moments01, moments01_recomputed, TOLERANCE)
      enddo
    enddo
    enddo

  end subroutine


  @Test
  subroutine test_approx_reconstruction()

  contains
    real*8 function levelSet(x) result(ans)
      implicit none

      real*8, intent(in)  :: x(2)

      ! ans = shift - dot_product(x, normal) - (kappa0/2) * (dot_product(x, tangent))**2

    end function
  end subroutine
end module