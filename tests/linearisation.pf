module linearisation
  use funit
  use m_common
  use m_r2d_parabolic

  real*8, parameter       :: TOLERANCE = 1E-8, STEP_SIZE = 1E-6

contains
  
  @Test
  subroutine test_samecell_derivatives()
    implicit none

    type(r2d_poly_f)      :: poly
    type(r2d_parabola_f)  :: parabola
    real*8                :: angle, normal(2), kappa0, x(2), pos(2, 7), radius
    real*8                :: derivative_cmp(4), derivative_fd(4), moments01(3), pi, grad_s(2)
    real*8                :: grad_s_cmp(2), grad_s_fd(2), shift
    integer               :: adx, kdx, sdx

    integer, parameter    :: NR_ANGLE = 20, NR_KAPPA = 20, NR_SHIFT = 20
    
    pi = 4 * datan(1.0D0)

    radius = 1.0D0
    x = [0.05D0, 0.03D0]
    
    ! Reconstruct in a polygonal approximation of a circle
    do adx=1,size(pos,2)
      angle = 2 * pi * (adx - 1.D0) / size(pos,2)
      pos(1,adx) = x(1) + radius * dcos(angle)
      pos(2,adx) = x(2) + radius * dsin(angle)
    enddo
    call init_from_pos(poly, pos)


    do adx=1,NR_ANGLE
    do kdx=1,NR_KAPPA
    do sdx=1,NR_SHIFT

      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)
 
      shift = (radius/2) * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))

      parabola = makeParabola(normal, kappa0, shift)

      ! We set the gradient of the shift to zero, such that the derivative of the first moment is computed
      ! nontrivially
      grad_s = 0.D0
      moments01 = cmpMoments(poly, parabola, x0=x, derivative=derivative_cmp, grad_s=grad_s)
      call approximate_moment_derivatives(poly, angle, kappa0, shift, x, derivative_fd, grad_s)

      @assertEqual(derivative_fd, derivative_cmp, TOLERANCE)

      ! Now we set grad_s to NAN, and hence we request the gradient of the shift (w.r.t. the angle and curvature)
      ! such that volume is conserved
      grad_s_cmp = d_qnan
      moments01 = cmpMoments(poly, parabola, derivative=derivative_cmp, grad_s=grad_s_cmp)
      call approximate_shift_derivatives(poly, moments01(1), angle, kappa0, shift, grad_s_fd)
      
      @assertEqual(grad_s_fd, grad_s_cmp, TOLERANCE)
    enddo
    enddo
    enddo

  end subroutine

  @Test
  subroutine test_othercell_derivatives()
    implicit none

    type(r2d_poly_f)      :: poly
    type(r2d_parabola_f)  :: parabola
    real*8                :: angle, normal(2), kappa0, x(2), pos(2, 7), radius
    real*8                :: derivative_cmp(4), derivative_fd(4), moments01(3), pi, grad_s(2)
    real*8                :: grad_s_cmp(2), grad_s_fd(2), shift, x0(2), shift_tau
    integer               :: adx, kdx, sdx, tdx

    integer, parameter    :: NR_ANGLE = 20, NR_KAPPA = 20, NR_SHIFT = 10, NR_SHIFT_TAU = 10

    pi = 4 * datan(1.0D0)

    radius = 1.0D0
    x = [0.05D0, 0.03D0]
    
    ! Reconstruct in a polygonal approximation of a circle
    do adx=1,size(pos,2)
      angle = 2 * pi * (adx - 1.D0) / size(pos,2)
      pos(1,adx) = x(1) + radius * dcos(angle)
      pos(2,adx) = x(2) + radius * dsin(angle)
    enddo
    call init_from_pos(poly, pos)


    do adx=1,NR_ANGLE
    do kdx=1,NR_KAPPA
    do sdx=1,NR_SHIFT
    do tdx=1,NR_SHIFT_TAU

      angle = 2 * pi * (adx - 1.D0) / NR_ANGLE
      normal = [dcos(angle), dsin(angle)]

      kappa0 = -1.D0 + 2 * (kdx - 1.D0) / (NR_KAPPA - 1.D0)

      shift = (radius/2) * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))
 
      shift_tau = radius * (-1.D0 + 2 * sdx / (NR_SHIFT + 1.D0))
      x0 = x + shift_tau * [-normal(1), normal(2)]

      parabola = makeParabola(normal, kappa0, shift)

      ! We set the gradient of the shift to zero, such that the derivative of the first moment is computed
      ! nontrivially
      grad_s = 0.D0
      moments01 = cmpMoments(poly, parabola, x0=x0, derivative=derivative_cmp, grad_s=grad_s)
      call approximate_moment_derivatives(poly, angle, kappa0, shift, x0, derivative_fd, grad_s)

      @assertEqual(derivative_fd, derivative_cmp, TOLERANCE)
    enddo
    enddo
    enddo
    enddo

  end subroutine

  subroutine approximate_moment_derivatives(poly, angle, kappa0, shift, x0, derivative, grad_s)
    implicit none
    
    type(r2d_poly_f), intent(in) :: poly
    real*8, intent(in)     :: angle, kappa0, shift, x0(2), grad_s(2)
    real*8, intent(inout)  :: derivative(4)
    
    ! Local variables
    real*8                :: moments_pos(3), moments_neg(3), dummy(4), grad_s_(2)

    grad_s_ = grad_s
    moments_pos = cmpMoments(poly, makeParabola(angle + STEP_SIZE, kappa0, shift),&
      x0=x0, derivative=dummy, grad_s=grad_s_)
    grad_s_ = grad_s
    moments_neg = cmpMoments(poly, makeParabola(angle - STEP_SIZE, kappa0, shift),&
      x0=x0, derivative=dummy, grad_s=grad_s_)
    
    derivative(1:3) = (moments_pos - moments_neg) / (2 * STEP_SIZE)
    
    grad_s_ = grad_s
    moments_pos = cmpMoments(poly, makeParabola(angle, kappa0 + STEP_SIZE, shift), &
      x0=x0, derivative=dummy, grad_s=grad_s_)
    grad_s_ = grad_s
    moments_neg = cmpMoments(poly, makeParabola(angle, kappa0 - STEP_SIZE, shift), &
      x0=x0, derivative=dummy, grad_s=grad_s_)
    
    derivative(4) = (moments_pos(1) - moments_neg(1)) / (2 * STEP_SIZE)

  end

  subroutine approximate_shift_derivatives(poly, volume, angle, kappa0, shift, grad_s)
    use m_reconstruction_util

    implicit none
    
    type(r2d_poly_f)       :: poly
    real*8, intent(in)     :: volume, angle, kappa0, shift
    real*8, intent(out)    :: grad_s(2)

    grad_s(1) = (cmpShift([dcos(angle + STEP_SIZE), dsin(angle + STEP_SIZE)], poly, volume, kappa0) - &
                 cmpShift([dcos(angle - STEP_SIZE), dsin(angle - STEP_SIZE)], poly, volume, kappa0)) / (2*STEP_SIZE)
    grad_s(2) = (cmpShift([dcos(angle), dsin(angle)], poly, volume, kappa0 + STEP_SIZE) - &
                 cmpShift([dcos(angle), dsin(angle)], poly, volume, kappa0 - STEP_SIZE)) / (2*STEP_SIZE)

  end
end module
